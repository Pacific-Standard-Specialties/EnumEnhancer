using Microsoft.CodeAnalysis.Text;
using PSS.EnumEnhancers.ExtensionMethods.Constants;

namespace PSS.EnumEnhancers.ExtensionMethods.Generators.EnumExtensions;

/// <summary>
///     Incremental code generator for enums decorated with <see cref="GenerateEnumExtensionMethodsAttribute" />.
/// </summary>
[SuppressMessage("CodeQuality", "IDE0079",
    Justification = "Suppressions here are intentional and the warnings they disable are just noise.")]
[Generator(LanguageNames.CSharp)]
public sealed class EnumExtensionMethodsIncrementalGenerator : IIncrementalGenerator
{
    private const string GeneratorAttributeFullyQualifiedName =
        $"{Strings.AttributesNamespace}.{GeneratorAttributeName}";

    private const string GeneratorAttributeName = nameof(GenerateEnumExtensionMethodsAttribute);

    /// <summary>Fully-qualified symbol name format without the "global::" prefix.</summary>
    private static readonly SymbolDisplayFormat _fullyQualifiedSymbolDisplayFormatWithoutGlobal =
        SymbolDisplayFormat.FullyQualifiedFormat.WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted);

    /// <inheritdoc />
    /// <remarks>
    ///     <para>
    ///         Basically, this method is called once by the compiler, and is responsible for wiring up
    ///         everything important about how source generation works.
    ///     </para>
    ///     <para>
    ///         See in-line comments for specifics of what's going on.
    ///     </para>
    ///     <para>
    ///         Note that <paramref name="context" /> is everything in the compilation,
    ///         except for code generated by this generator or generators which have not yet executed.<br />
    ///         The methods registered to perform generation get called on-demand by the host (the IDE,
    ///         compiler, etc), sometimes as often as every single keystroke.
    ///     </para>
    /// </remarks>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Write out namespaces that may be used later. Harmless to declare them now and will avoid
        // additional processing and potential omissions later on.
        context.RegisterPostInitializationOutput(GenerateDummyNamespaces);

        IncrementalValuesProvider<EnumExtensionMethodsGenerationInfo?> enumGenerationInfos =
            context
                .SyntaxProvider
                .ForAttributeWithMetadataName(
                    GeneratorAttributeFullyQualifiedName,
                    IsPotentiallyInterestingDeclaration,
                    GatherMetadataForCodeGeneration
                )
                .WithTrackingName("CollectEnumMetadata")
                .Where(static eInfo => eInfo is { });

        context.RegisterSourceOutput(enumGenerationInfos, GenerateSourceFromGenerationInfo);
    }

    private static EnumExtensionMethodsGenerationInfo? GatherMetadataForCodeGeneration(
        GeneratorAttributeSyntaxContext context,
        CancellationToken cancellationToken
    )
    {
        CancellationTokenSource cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
        cancellationToken.ThrowIfCancellationRequested();

        // If it's not an enum symbol, we don't care.
        // EnumUnderlyingType is null for non-enums, so this validates it's an enum declaration.
        if (context.TargetSymbol is not INamedTypeSymbol { EnumUnderlyingType: { } } namedSymbol)
        {
          return null;
        }

        INamespaceSymbol? enumNamespaceSymbol = namedSymbol.ContainingNamespace;

        if (enumNamespaceSymbol is null or { IsGlobalNamespace: true })
            // Explicitly choosing not to support enums in the global namespace.
            // The corresponding analyzer will report this.
        {
          return null;
        }

        string enumName = namedSymbol.Name;

        string enumNamespace = enumNamespaceSymbol.ToDisplayString(_fullyQualifiedSymbolDisplayFormatWithoutGlobal);

        TypeCode enumTypeCode = namedSymbol.EnumUnderlyingType.Name switch
                                {
                                  "UInt32" => TypeCode.UInt32,
                                  "Int32" => TypeCode.Int32,
                                  _ => TypeCode.Empty
                                };

        EnumExtensionMethodsGenerationInfo info = new(
            enumNamespace,
            enumName,
            enumTypeCode
        );

        if (!info.TryConfigure(namedSymbol, cts.Token))
        {
            cts.Cancel();
            cts.Token.ThrowIfCancellationRequested();
        }

        return info;
    }

    [SuppressMessage("Roslynator", "RCS1267", Justification = "Intentionally used so that Spans are used.")]
    private static void GenerateDummyNamespaces(IncrementalGeneratorPostInitializationContext postInitializeContext)
    {
        postInitializeContext.AddSource(
            string.Concat(Strings.EnumEnhancerRootNamespace, "Namespaces.g.cs"),
            SourceText.From(Strings.Templates.DummyNamespaceDeclarations, Encoding.UTF8));
    }

    private static void GenerateSourceFromGenerationInfo(SourceProductionContext context,
        EnumExtensionMethodsGenerationInfo? enumInfo)
    {
        // Just in case we still made it this far with a null...
        if (enumInfo is null)
        {
          return;
        }

        CodeWriter writer = new(enumInfo);

        context.AddSource($"{enumInfo.FullyQualifiedClassName}.g.cs", writer.GenerateSourceText());
    }

    /// <summary>
    ///     Returns true if <paramref name="syntaxNode" /> is an EnumDeclarationSyntax
    ///     whose parent is a NamespaceDeclarationSyntax, FileScopedNamespaceDeclarationSyntax, or a
    ///     (Class|Struct)DeclarationSyntax.<br />
    ///     Additional filtering is performed in later stages.
    /// </summary>
    private static bool IsPotentiallyInterestingDeclaration(SyntaxNode syntaxNode, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        return syntaxNode is
        {
            RawKind: 8858, //(int)SyntaxKind.EnumDeclaration,
            Parent.RawKind: 8845 //(int)SyntaxKind.FileScopedNamespaceDeclaration
            or 8842 //(int)SyntaxKind.NamespaceDeclaration
            or 8855 //(int)SyntaxKind.ClassDeclaration
            or 8856 //(int)SyntaxKind.StructDeclaration
            or 9068 //(int)SyntaxKind.RecordStructDeclaration
            or 9063 //(int)SyntaxKind.RecordDeclaration
        };
    }
}